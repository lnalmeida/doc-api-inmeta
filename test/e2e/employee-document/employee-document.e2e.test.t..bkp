import * as request from 'supertest';
import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { AppModule } from '../../../src/app.module'; 
import { PrismaService } from '../../../src/database/prisma.service'; 
import { config } from 'dotenv';
import { DocumentStatus } from '@prisma/client';
import { generateValidCpf } from '../../../src/common/utils/generate-valid-cpf';
import { v4 } from 'uuid';

// Carrega o .env.test para este ambiente de teste
config({ path: '.env.test', override: true });

// CPFs VÁLIDOS (gerados de forma a passar na validação de algoritmo)
const mockEmployeeData1 = { name: 'Ana Docs', cpf: '153.332.570-78', hiredAt: '2024-01-01' };
const mockEmployeeData2 = { name: 'Bruno Docs', cpf:'555.226.310-31', hiredAt: '2024-02-01' };
const mockDocTypeDataCPF = { name: 'CPF' };
const mockDocTypeDataRG = { name: 'RG'};
const mockDocTypeDataCTPS = { name: 'CTPS' };

describe('EmployeeDocumentsController (e2e)', () => {
  let app: INestApplication;
  let prismaService: PrismaService;

  process.env.NODE_ENV = 'test'; 

  let employeeId1: string;
  let employeeId2: string;
  let docTypeIdCPF: string;
  let docTypeIdRG: string;
  let docTypeIdCTPS: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    
    app = moduleFixture.createNestApplication();

    prismaService = moduleFixture.get<PrismaService>(PrismaService);

    app.useGlobalPipes(new (await import('@nestjs/common')).ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }));

    app.useGlobalFilters(new (await import('../../../src/common/filters/global-http-exception.filter')).AllExceptionsFilter());

    await app.init();
  });

  beforeEach(async () => {
    await prismaService.$transaction([
      prismaService.employeeDocument.deleteMany({}),
      prismaService.employee.deleteMany({}),
      prismaService.documentType.deleteMany({}),
    ]);

    // Cria dados básicos (colaboradores e tipos de documentos) para os testes
    // CPFs válidos garantem que os POSTs retornem 201
    employeeId1 = (await request(app.getHttpServer()).post('/employee').send({ name: 'Ana Docs', cpf: '000.000.000-01', hiredAt: '2024-01-01' }).expect(201)).body.id;
    employeeId2 = (await request(app.getHttpServer()).post('/employee').send({ name: 'Bruno Docs', cpf: '000.000.000-02', hiredAt: '2024-02-01' }).expect(201)).body.id;
    docTypeIdCPF = (await request(app.getHttpServer()).post('/document-type').send({ name: 'CPF' }).expect(201)).body.id;
    docTypeIdRG = (await request(app.getHttpServer()).post('/document-type').send({ name: 'RG' }).expect(201)).body.id;
    docTypeIdCTPS = (await request(app.getHttpServer()).post('/document-type').send({ name: 'CTPS' }).expect(201)).body.id;
  });

  afterAll(async () => {
    await prismaService.employeeDocument.deleteMany({});
    await prismaService.employee.deleteMany({});
    await prismaService.documentType.deleteMany({});
    await app.close();
  });


  // Testes para Atribuição
  describe('POST /employee-documents/assign', () => {
    it('deve vincular tipos de documentos a um colaborador com sucesso', async () => {
      const assignDto = { employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdRG] };
      const res = await request(app.getHttpServer()).post('/employee-documents/assign').send(assignDto).expect(201);

      expect(res.body.message).toBe('Tipos de documentos vinculados com sucesso.');
      expect(res.body.assignedDocumentsCount).toBe(2);
      const assignedDocs = await prismaService.employeeDocument.findMany({ where: { employeeId: employeeId1 } });
      expect(assignedDocs.length).toBe(2);
      expect(assignedDocs.every((d: any)=> d.status === DocumentStatus.PENDING)).toBeTruthy();
    });

    it('não deve vincular se colaborador não existir', async () => {
      const nonExistentEmployeeId = v4();
      const assignDto = { employeeId: nonExistentEmployeeId, documentTypeIds: [docTypeIdCPF] };
      const res = await request(app.getHttpServer()).post('/employee-documents/assign').send(assignDto).expect(404);
      
      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe('/employee-documents/assign');
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Colaborador com ID "${nonExistentEmployeeId}" não encontrado.`, // Mensagem corrigida com aspas
        statusCode: 404,
      });
    });

    it('não deve vincular se tipo de documento não existir', async () => {
      const nonExistentDocTypeId = v4(); 
      const assignDto = { employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, nonExistentDocTypeId] };
      const res = await request(app.getHttpServer()).post('/employee-documents/assign').send(assignDto).expect(400);

      expect(res.statusCode).toBe(400);
      expect(res.body.path).toBe('/employee-documents/assign');
      expect(res.body.message).toMatchObject({
        error: 'Bad Request',
        message: `Os seguintes IDs de tipo de documento são inválidos ou não existem: ${nonExistentDocTypeId}`, // Mensagem corrigida
        statusCode: 400,
      });
    });

    it('não deve vincular se já atribuído', async () => {
      const assignDto = { employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdRG] };
      await request(app.getHttpServer()).post('/employee-documents/assign').send(assignDto).expect(201); 
      
      const reAssignDto = { employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdCTPS] }; 
      const res = await request(app.getHttpServer()).post('/employee-documents/assign').send(reAssignDto).expect(409);

      expect(res.statusCode).toBe(409);
      expect(res.body.path).toBe('/employee-documents/assign');
      expect(res.body.message).toMatchObject({
        error: 'Conflict',
        message: `O(s) tipo(s) de documento "CPF" já está(ão) vinculado(s) ao colaborador "${mockEmployeeData1.name}".`, // Mensagem corrigida com aspas no nome
        statusCode: 409,
      });
    });
  });


  // Testes para Desvinculação
  describe('DELETE /employee-documents/unassign', () => {
    beforeEach(async () => {
      await request(app.getHttpServer()).post('/employee-documents/assign').send({ employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdRG] }).expect(201);
    });

    it('deve desvincular tipos de documentos com sucesso', async () => {
      const unassignDto = { employeeId: employeeId1, documentTypeIds: [docTypeIdCPF] };
      await request(app.getHttpServer()).delete('/employee-documents/unassign').send(unassignDto).expect(204);

      const remainingDocs = await prismaService.employeeDocument.findMany({ where: { employeeId: employeeId1 } });
      expect(remainingDocs.length).toBe(1); 
      expect(remainingDocs[0].documentTypeId).toBe(docTypeIdRG); 
    });

    it('não deve desvincular se colaborador não existir', async () => {
      const nonExistentEmployeeId = v4();
      const unassignDto = { employeeId: nonExistentEmployeeId, documentTypeIds: [docTypeIdCPF] };
      const res = await request(app.getHttpServer()).delete('/employee-documents/unassign').send(unassignDto).expect(404);

      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe('/employee-documents/unassign');
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Colaborador com ID "${nonExistentEmployeeId}" não encontrado.`, // Mensagem corrigida
        statusCode: 404,
      });
    });
  });


  // Testes para Envio
  describe('PATCH /employee-documents/submit', () => {
    beforeEach(async () => {
      await request(app.getHttpServer()).post('/employee-documents/assign').send({ employeeId: employeeId1, documentTypeIds: [docTypeIdCPF] }).expect(201);
    });

    it('deve registrar o envio de um documento com sucesso', async () => {
      const submitDto = { employeeId: employeeId1, documentTypeId: docTypeIdCPF };
      const res = await request(app.getHttpServer()).patch('/employee-documents/submit').send(submitDto).expect(200);

      expect(res.body.status).toBe(DocumentStatus.SUBMITTED);
      expect(res.body.submittedAt).toBeDefined();
      const submittedDoc = await prismaService.employeeDocument.findUnique({ where: { employeeId_documentTypeId: { employeeId: employeeId1, documentTypeId: docTypeIdCPF } } });
      expect(submittedDoc?.status).toBe(DocumentStatus.SUBMITTED);
      expect(submittedDoc?.submittedAt).not.toBeNull();
    });

    it('não deve registrar envio se colaborador não existir', async () => {
      const nonExistentEmployeeId = v4(); // UUID válido
      const submitDto = { employeeId: nonExistentEmployeeId, documentTypeId: docTypeIdCPF };
      const res = await request(app.getHttpServer()).patch('/employee-documents/submit').send(submitDto).expect(404);

      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe('/employee-documents/submit');
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Colaborador com ID "${nonExistentEmployeeId}" não encontrado.`,
        statusCode: 404,
      });
    });

    it('não deve registrar envio se tipo de documento não existir', async () => {
      const nonExistentDocTypeId = v4();
      const submitDto = { employeeId: employeeId1, documentTypeId: nonExistentDocTypeId };
      const res = await request(app.getHttpServer()).patch('/employee-documents/submit').send(submitDto).expect(404);

      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe('/employee-documents/submit');
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Tipo de documento com ID "${nonExistentDocTypeId}" não encontrado.`,
        statusCode: 404,
      });
    });

    it('não deve registrar envio se não vinculado ou já enviado', async () => {
      const nonAssignedDocTypeRes = await request(app.getHttpServer()).post('/document-type').send({ name: 'CNH-NãoAtribuida', description: 'CNH' }).expect(201);
      const nonAssignedDocTypeId = nonAssignedDocTypeRes.body.id;
      const submitDto = { employeeId: employeeId1, documentTypeId: nonAssignedDocTypeId };

      const res = await request(app.getHttpServer()).patch('/employee-documents/submit').send(submitDto).expect(404); 

      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe('/employee-documents/submit');
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Documento do tipo "CNH-NãoAtribuida" não vinculado ou já enviado para o colaborador "${mockEmployeeData1.name}".`,
        statusCode: 404,
      });
    });

    it('não deve registrar envio se já enviado anteriormente', async () => {
      await request(app.getHttpServer()).patch('/employee-documents/submit').send({ employeeId: employeeId1, documentTypeId: docTypeIdCPF }).expect(200);
      const res = await request(app.getHttpServer()).patch('/employee-documents/submit').send({ employeeId: employeeId1, documentTypeId: docTypeIdCPF }).expect(409);

      expect(res.statusCode).toBe(409);
      expect(res.body.path).toBe('/employee-documents/submit');
      expect(res.body.message).toMatchObject({
        error: 'Conflict',
        message: `O documento "CPF" do colaborador "${mockEmployeeData1.name}" já foi enviado.`,
        statusCode: 409,
      });
    });
  });


  // Testes para Obter Status de Documentação por Colaborador
  describe('GET /employee-documents/status/:employeeId', () => {
    beforeEach(async () => {
      await request(app.getHttpServer()).post('/employee-documents/assign').send({ employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdRG, docTypeIdCTPS] }).expect(201);
      await request(app.getHttpServer()).patch('/employee-documents/submit').send({ employeeId: employeeId1, documentTypeId: docTypeIdCPF }).expect(200);
    });

    it('deve retornar o status detalhado da documentação de um colaborador', async () => {
      const res = await request(app.getHttpServer()).get(`/employee-documents/status/${employeeId1}`).expect(200);

      expect(res.body.employeeId).toBe(employeeId1);
      expect(res.body.employeeName).toBe(mockEmployeeData1.name);
      expect(res.body.documents).toBeInstanceOf(Array);
      expect(res.body.documents.length).toBe(3); 

      const cpfDoc = res.body.documents.find((d: any) => d.documentTypeName === mockDocTypeDataCPF.name);
      const rgDoc = res.body.documents.find((d: any) => d.documentTypeName === mockDocTypeDataRG.name);
      const ctpsDoc = res.body.documents.find((d: any) => d.documentTypeName === mockDocTypeDataCTPS.name);

      expect(cpfDoc.status).toBe(DocumentStatus.SUBMITTED);
      expect(cpfDoc.submittedAt).toBeDefined();
      expect(rgDoc.status).toBe(DocumentStatus.PENDING);
      expect(rgDoc.submittedAt).toBeNull();
      expect(ctpsDoc.status).toBe(DocumentStatus.PENDING);
      expect(ctpsDoc.submittedAt).toBeNull();
    });

    it('deve retornar 404 se colaborador não for encontrado', async () => {
      const nonExistentId = v4();
      const res = await request(app.getHttpServer()).get(`/employee-documents/status/${nonExistentId}`).expect(404);

      expect(res.statusCode).toBe(404);
      expect(res.body.path).toBe(`/employee-documents/status/${nonExistentId}`);
      expect(res.body.message).toMatchObject({
        error: 'Not Found',
        message: `Colaborador com ID "${nonExistentId}" não encontrado.`,
        statusCode: 404,
      });
    });
  });


  // Testes para Listar Documentos Pendentes Agrupados
  describe('GET /employee-documents/pending', () => {
    beforeEach(async () => {
      // Colaborador 1: 2 documentos pendentes (RG, CTPS), 1 enviado (CPF)
      await request(app.getHttpServer()).post('/employee-documents/assign').send({ employeeId: employeeId1, documentTypeIds: [docTypeIdCPF, docTypeIdRG, docTypeIdCTPS] }).expect(201);
      await request(app.getHttpServer()).patch('/employee-documents/submit').send({ employeeId: employeeId1, documentTypeId: docTypeIdCPF }).expect(200);

      // Colaborador 2: 2 documentos pendentes (CPF, RG)
      await request(app.getHttpServer()).post('/employee-documents/assign').send({ employeeId: employeeId2, documentTypeIds: [docTypeIdCPF, docTypeIdRG] }).expect(201); // CORRIGIDO: /employee-documents/assign
    });

    it('deve listar documentos pendentes agrupados por colaborador com paginação', async () => {
      const res = await request(app.getHttpServer()).get('/employee-documents/pending?page=1&limit=1').expect(200);

      expect(res.body.data).toBeInstanceOf(Array);
      expect(res.body.data.length).toBe(1); 
      expect(res.body.totalEmployees).toBe(2); 
      expect(res.body.totalPendingDocuments).toBe(4); 
      expect(res.body.page).toBe(1);
      expect(res.body.limit).toBe(1);
      expect(res.body.totalPages).toBe(2);

      const firstGroupedEmployee = res.body.data[0];
      expect(firstGroupedEmployee.employeeId).toBeDefined();
      expect(firstGroupedEmployee.employeeName).toBeDefined();
      expect(firstGroupedEmployee.documents).toBeInstanceOf(Array);
      expect(firstGroupedEmployee.documents.every((d: any) => d.status === DocumentStatus.PENDING)).toBeTruthy();
      
      const resPage2 = await request(app.getHttpServer()).get('/employee-documents/pending?page=2&limit=1').expect(200);
      expect(resPage2.body.data.length).toBe(1);
      expect(resPage2.body.totalEmployees).toBe(2);
      expect(resPage2.body.totalPendingDocuments).toBe(4);
      expect(resPage2.body.page).toBe(2);
      expect(resPage2.body.limit).toBe(1);
      expect(resPage2.body.totalPages).toBe(2);
    });

    it('deve listar documentos pendentes filtrados por colaborador', async () => {
      const res = await request(app.getHttpServer()).get(`/employee-documents/pending?employeeId=${employeeId1}`).expect(200);

      expect(res.body.data.length).toBe(1);
      expect(res.body.data[0].employeeId).toBe(employeeId1);
      expect(res.body.data[0].documents.length).toBe(2); 
      expect(res.body.totalEmployees).toBe(1);
      expect(res.body.totalPendingDocuments).toBe(2);
    });

    it('deve listar documentos pendentes filtrados por tipo de documento', async () => {
      const res = await request(app.getHttpServer()).get(`/employee-documents/pending?documentTypeId=${docTypeIdRG}`).expect(200);
        
      expect(res.body.data.length).toBe(2); 
      expect(res.body.totalEmployees).toBe(2);
      expect(res.body.totalPendingDocuments).toBe(2);
      expect(res.body.data.every((e: any) => e.documents.some((d: any) => d.documentTypeId === docTypeIdRG))).toBeTruthy();
    });

    it('deve retornar uma lista vazia se não houver documentos pendentes com os filtros', async () => {
      const res = await request(app.getHttpServer()).get('/employee-documents/pending?documentTypeId=non-existent-doc-type').expect(200);

      expect(res.body.data.length).toBe(0);
      expect(res.body.totalEmployees).toBe(0);
      expect(res.body.totalPendingDocuments).toBe(0);
    });
  });
});